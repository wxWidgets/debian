<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>wxWidgets: wxThread Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="extra_stylesheet.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="page_container">
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0" style="width: 100%;">
 <tbody>
 <tr>
  <td id="projectlogo">
    <a href="http://www.wxwidgets.org/" target="_new">
      <img alt="wxWidgets" src="logo.png"/>
    </a>
  </td>
  <td style="padding-left: 0.5em; text-align: right;">
   <span id="projectnumber">Version: 3.0.2</span>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- Generated by Doxygen 1.8.2 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Categories</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="classwx_thread-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">wxThread Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span><div class="ingroups"><a class="el" href="group__group__class__threading.html">Threading</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;wx/thread.h&gt;</code></p>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A thread is basically a path of execution through a program. </p>
<p>Threads are sometimes called <em>light-weight</em> processes, but the fundamental difference between threads and processes is that memory spaces of different processes are separated while all threads share the same address space.</p>
<p>While it makes it much easier to share common data between several threads, it also makes it much easier to shoot oneself in the foot, so careful use of synchronization objects such as mutexes (see <a class="el" href="classwx_mutex.html" title="A mutex object is a synchronization object whose state is set to signaled when it is not owned by any...">wxMutex</a>) or critical sections (see <a class="el" href="classwx_critical_section.html" title="A critical section object is used for exactly the same purpose as a wxMutex.">wxCriticalSection</a>) is recommended. In addition, don't create global thread objects because they allocate memory in their constructor, which will cause problems for the memory checking system.</p>
<h1><a class="anchor" id="thread_types"></a>
Types of wxThreads</h1>
<p>There are two types of threads in wxWidgets: <em>detached</em> and <em>joinable</em>, modeled after the POSIX thread API. This is different from the Win32 API where all threads are joinable.</p>
<p>By default wxThreads in wxWidgets use the <b>detached</b> behaviour. Detached threads delete themselves once they have completed, either by themselves when they complete processing or through a call to <a class="el" href="classwx_thread.html#a66796042bf5f3eb33a0ad3db85f686d4" title="Calling Delete() gracefully terminates a detached thread, either when the thread calls TestDestroy() ...">Delete()</a>, and thus <b>must</b> be created on the heap (through the new operator, for example).</p>
<p>Typically you'll want to store the instances of the detached wxThreads you allocate, so that you can call functions on them. Because of their nature however you'll need to always use a critical section when accessing them:</p>
<div class="fragment"><div class="line"><span class="comment">// declare a new type of event, to be used by our MyThread class:</span></div>
<div class="line"><a class="code" href="group__group__funcmacro__events.html#ga767b12d37f7370bc5f6b3d62340f3ef8" title="Declares a custom event type.">wxDECLARE_EVENT</a>(wxEVT_COMMAND_MYTHREAD_COMPLETED, <a class="code" href="classwx_thread_event.html" title="This class adds some simple functionality to wxEvent to facilitate inter-thread communication.">wxThreadEvent</a>);</div>
<div class="line"><a class="code" href="group__group__funcmacro__events.html#ga767b12d37f7370bc5f6b3d62340f3ef8" title="Declares a custom event type.">wxDECLARE_EVENT</a>(wxEVT_COMMAND_MYTHREAD_UPDATE, <a class="code" href="classwx_thread_event.html" title="This class adds some simple functionality to wxEvent to facilitate inter-thread communication.">wxThreadEvent</a>);</div>
<div class="line"><span class="keyword">class </span>MyFrame;</div>
<div class="line"></div>
<div class="line"><span class="keyword">class </span>MyThread : <span class="keyword">public</span> <a class="code" href="classwx_thread.html" title="A thread is basically a path of execution through a program.">wxThread</a></div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    MyThread(MyFrame *handler)</div>
<div class="line">        : <a class="code" href="classwx_thread.html" title="A thread is basically a path of execution through a program.">wxThread</a>(<a class="code" href="interface_2wx_2thread_8h.html#a0dc9a167e8d084946512da99b37b5fd0acd9af5dbbc12a95684ab6e7be16e30c9" title="Detached thread.">wxTHREAD_DETACHED</a>)</div>
<div class="line">        { m_pHandler = handler }</div>
<div class="line">    ~MyThread();</div>
<div class="line"></div>
<div class="line"><span class="keyword">protected</span>:</div>
<div class="line">    <span class="keyword">virtual</span> <a class="code" href="classwx_thread.html#ade9497fa072fe19481086e6486dcc028" title="The return type for the thread functions.">ExitCode</a> <a class="code" href="classwx_thread.html#af50fa7d3ac55002e367e79989b9cbc5d" title="This is the entry point of the thread.">Entry</a>();</div>
<div class="line">    MyFrame *m_pHandler;</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="keyword">class </span>MyFrame : <span class="keyword">public</span> <a class="code" href="classwx_frame.html" title="A frame is a window whose size and position can (usually) be changed by the user.">wxFrame</a></div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    ...</div>
<div class="line">    ~MyFrame()</div>
<div class="line">    {</div>
<div class="line">        <span class="comment">// it&#39;s better to do any thread cleanup in the OnClose()</span></div>
<div class="line">        <span class="comment">// event handler, rather than in the destructor.</span></div>
<div class="line">        <span class="comment">// This is because the event loop for a top-level window is not</span></div>
<div class="line">        <span class="comment">// active anymore when its destructor is called and if the thread</span></div>
<div class="line">        <span class="comment">// sends events when ending, they won&#39;t be processed unless</span></div>
<div class="line">        <span class="comment">// you ended the thread from OnClose.</span></div>
<div class="line">        <span class="comment">// See @ref overview_windowdeletion for more info.</span></div>
<div class="line">    }</div>
<div class="line">    ...</div>
<div class="line">    <span class="keywordtype">void</span> DoStartThread();</div>
<div class="line">    <span class="keywordtype">void</span> DoPauseThread();</div>
<div class="line"></div>
<div class="line">    <span class="comment">// a resume routine would be nearly identic to DoPauseThread()</span></div>
<div class="line">    <span class="keywordtype">void</span> DoResumeThread() { ... }</div>
<div class="line"></div>
<div class="line">    <span class="keywordtype">void</span> OnThreadUpdate(<a class="code" href="classwx_thread_event.html" title="This class adds some simple functionality to wxEvent to facilitate inter-thread communication.">wxThreadEvent</a>&amp;);</div>
<div class="line">    <span class="keywordtype">void</span> OnThreadCompletion(<a class="code" href="classwx_thread_event.html" title="This class adds some simple functionality to wxEvent to facilitate inter-thread communication.">wxThreadEvent</a>&amp;);</div>
<div class="line">    <span class="keywordtype">void</span> OnClose(<a class="code" href="classwx_close_event.html" title="This event class contains information about window and session close events.">wxCloseEvent</a>&amp;);</div>
<div class="line"></div>
<div class="line"><span class="keyword">protected</span>:</div>
<div class="line">    MyThread *m_pThread;</div>
<div class="line">    <a class="code" href="classwx_critical_section.html" title="A critical section object is used for exactly the same purpose as a wxMutex.">wxCriticalSection</a> m_pThreadCS;    <span class="comment">// protects the m_pThread pointer</span></div>
<div class="line"></div>
<div class="line">    <a class="code" href="group__group__funcmacro__events.html#gab6eca03fad44ec10b75d3cb82e9219e3" title="Use this macro inside a class declaration to declare a static event table for that class...">wxDECLARE_EVENT_TABLE</a>();</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><a class="code" href="group__group__funcmacro__events.html#ga736930efaab4d7e445e9e8e520c7b74d" title="Use this macro in a source file to start listing static event handlers for a specific class...">wxBEGIN_EVENT_TABLE</a>(MyFrame, <a class="code" href="classwx_frame.html" title="A frame is a window whose size and position can (usually) be changed by the user.">wxFrame</a>)</div>
<div class="line">    EVT_CLOSE(MyFrame::OnClose)</div>
<div class="line">    EVT_MENU(Minimal_Start,  MyFrame::DoStartThread)</div>
<div class="line">    EVT_COMMAND(<a class="code" href="defs_8h.html#ac66d0a09761e7d86b2ac0b2e0c6a8cbba1f375b01ea03a713bbb7e32a36a2589c" title="Any id: means that we don&#39;t care about the id, whether when installing an event handler or when creat...">wxID_ANY</a>, wxEVT_COMMAND_MYTHREAD_UPDATE, MyFrame::OnThreadUpdate)</div>
<div class="line">    EVT_COMMAND(wxID_ANY, wxEVT_COMMAND_MYTHREAD_COMPLETED, MyFrame::OnThreadCompletion)</div>
<div class="line"><a class="code" href="group__group__funcmacro__events.html#ga383fad2a46e1d6c220fbe03ecfbc9c17" title="Use this macro in a source file to end listing static event handlers for a specific class...">wxEND_EVENT_TABLE</a>()</div>
<div class="line"></div>
<div class="line"><a class="code" href="group__group__funcmacro__events.html#ga09ec1d095bee3085c1cb31459b46bc00" title="Define a new event type associated with the specified event class.">wxDEFINE_EVENT</a>(wxEVT_COMMAND_MYTHREAD_COMPLETED, <a class="code" href="classwx_thread_event.html" title="This class adds some simple functionality to wxEvent to facilitate inter-thread communication.">wxThreadEvent</a>)</div>
<div class="line"><a class="code" href="group__group__funcmacro__events.html#ga09ec1d095bee3085c1cb31459b46bc00" title="Define a new event type associated with the specified event class.">wxDEFINE_EVENT</a>(wxEVT_COMMAND_MYTHREAD_UPDATE, <a class="code" href="classwx_thread_event.html" title="This class adds some simple functionality to wxEvent to facilitate inter-thread communication.">wxThreadEvent</a>)</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> MyFrame::DoStartThread()</div>
<div class="line">{</div>
<div class="line">    m_pThread = <span class="keyword">new</span> MyThread(<span class="keyword">this</span>);</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">if</span> ( m_pThread-&gt;Run() != <a class="code" href="interface_2wx_2thread_8h.html#a9e4ba0577f752fee0ba2133035f75ac2ad1525fe128b4989cb43a7e8112ac1b13" title="No error.">wxTHREAD_NO_ERROR</a> )</div>
<div class="line">    {</div>
<div class="line">        <a class="code" href="group__group__funcmacro__log.html#ga0dd3c633f990f794e76065c9a7af4c87" title="The functions to use for error messages, i.e.">wxLogError</a>(<span class="stringliteral">&quot;Can&#39;t create the thread!&quot;</span>);</div>
<div class="line">        <span class="keyword">delete</span> m_pThread;</div>
<div class="line">        m_pThread = NULL;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="comment">// after the call to wxThread::Run(), the m_pThread pointer is &quot;unsafe&quot;:</span></div>
<div class="line">    <span class="comment">// at any moment the thread may cease to exist (because it completes its work).</span></div>
<div class="line">    <span class="comment">// To avoid dangling pointers OnThreadExit() will set m_pThread</span></div>
<div class="line">    <span class="comment">// to NULL when the thread dies.</span></div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><a class="code" href="classwx_thread.html#ade9497fa072fe19481086e6486dcc028" title="The return type for the thread functions.">wxThread::ExitCode</a> MyThread::Entry()</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">while</span> (!<a class="code" href="classwx_thread.html#a9a3acec44b06b2a2430c5659991a3eac" title="This function should be called periodically by the thread to ensure that calls to Pause() and Delete(...">TestDestroy</a>())</div>
<div class="line">    {</div>
<div class="line">        <span class="comment">// ... do a bit of work...</span></div>
<div class="line"></div>
<div class="line">        <a class="code" href="group__group__funcmacro__events.html#gae921d7bd0e52fedbf3f253d2c408bce1" title="Queue an event for processing on the given object.">wxQueueEvent</a>(m_pHandler, <span class="keyword">new</span> <a class="code" href="classwx_thread_event.html" title="This class adds some simple functionality to wxEvent to facilitate inter-thread communication.">wxThreadEvent</a>(wxEVT_COMMAND_MYTHREAD_UPDATE));</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="comment">// signal the event handler that this thread is going to be destroyed</span></div>
<div class="line">    <span class="comment">// NOTE: here we assume that using the m_pHandler pointer is safe,</span></div>
<div class="line">    <span class="comment">//       (in this case this is assured by the MyFrame destructor)</span></div>
<div class="line">    <a class="code" href="group__group__funcmacro__events.html#gae921d7bd0e52fedbf3f253d2c408bce1" title="Queue an event for processing on the given object.">wxQueueEvent</a>(m_pHandler, <span class="keyword">new</span> <a class="code" href="classwx_thread_event.html" title="This class adds some simple functionality to wxEvent to facilitate inter-thread communication.">wxThreadEvent</a>(wxEVT_COMMAND_MYTHREAD_COMPLETED));</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">return</span> (<a class="code" href="classwx_thread.html#ade9497fa072fe19481086e6486dcc028" title="The return type for the thread functions.">wxThread::ExitCode</a>)0;     <span class="comment">// success</span></div>
<div class="line">}</div>
<div class="line"></div>
<div class="line">MyThread::~MyThread()</div>
<div class="line">{</div>
<div class="line">    <a class="code" href="classwx_critical_section_locker.html" title="This is a small helper class to be used with wxCriticalSection objects.">wxCriticalSectionLocker</a> enter(m_pHandler-&gt;m_pThreadCS);</div>
<div class="line"></div>
<div class="line">    <span class="comment">// the thread is being destroyed; make sure not to leave dangling pointers around</span></div>
<div class="line">    m_pHandler-&gt;m_pThread = NULL;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> MyFrame::OnThreadCompletion(<a class="code" href="classwx_thread_event.html" title="This class adds some simple functionality to wxEvent to facilitate inter-thread communication.">wxThreadEvent</a>&amp;)</div>
<div class="line">{</div>
<div class="line">    <a class="code" href="classwx_message_output_debug.html" title="Output messages to the system debug output channel.">wxMessageOutputDebug</a>().<a class="code" href="classwx_message_output.html#a233e76ce6c1b569f16b42b49151ab979" title="Output a message.">Printf</a>(<span class="stringliteral">&quot;MYFRAME: MyThread exited!\n&quot;</span>);</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> MyFrame::OnThreadUpdate(<a class="code" href="classwx_thread_event.html" title="This class adds some simple functionality to wxEvent to facilitate inter-thread communication.">wxThreadEvent</a>&amp;)</div>
<div class="line">{</div>
<div class="line">    <a class="code" href="classwx_message_output_debug.html" title="Output messages to the system debug output channel.">wxMessageOutputDebug</a>().<a class="code" href="classwx_message_output.html#a233e76ce6c1b569f16b42b49151ab979" title="Output a message.">Printf</a>(<span class="stringliteral">&quot;MYFRAME: MyThread update...\n&quot;</span>);</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> MyFrame::DoPauseThread()</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// anytime we access the m_pThread pointer we must ensure that it won&#39;t</span></div>
<div class="line">    <span class="comment">// be modified in the meanwhile; since only a single thread may be</span></div>
<div class="line">    <span class="comment">// inside a given critical section at a given time, the following code</span></div>
<div class="line">    <span class="comment">// is safe:</span></div>
<div class="line">    <a class="code" href="classwx_critical_section_locker.html" title="This is a small helper class to be used with wxCriticalSection objects.">wxCriticalSectionLocker</a> enter(m_pThreadCS);</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">if</span> (m_pThread)         <span class="comment">// does the thread still exist?</span></div>
<div class="line">    {</div>
<div class="line">        <span class="comment">// without a critical section, once reached this point it may happen</span></div>
<div class="line">        <span class="comment">// that the OS scheduler gives control to the MyThread::Entry() function,</span></div>
<div class="line">        <span class="comment">// which in turn may return (because it completes its work) making</span></div>
<div class="line">        <span class="comment">// invalid the m_pThread pointer</span></div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">if</span> (m_pThread-&gt;Pause() != <a class="code" href="interface_2wx_2thread_8h.html#a9e4ba0577f752fee0ba2133035f75ac2ad1525fe128b4989cb43a7e8112ac1b13" title="No error.">wxTHREAD_NO_ERROR</a> )</div>
<div class="line">            <a class="code" href="group__group__funcmacro__log.html#ga0dd3c633f990f794e76065c9a7af4c87" title="The functions to use for error messages, i.e.">wxLogError</a>(<span class="stringliteral">&quot;Can&#39;t pause the thread!&quot;</span>);</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> MyFrame::OnClose(<a class="code" href="classwx_close_event.html" title="This event class contains information about window and session close events.">wxCloseEvent</a>&amp;)</div>
<div class="line">{</div>
<div class="line">    {</div>
<div class="line">        <a class="code" href="classwx_critical_section_locker.html" title="This is a small helper class to be used with wxCriticalSection objects.">wxCriticalSectionLocker</a> enter(m_pThreadCS);</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">if</span> (m_pThread)         <span class="comment">// does the thread still exist?</span></div>
<div class="line">        {</div>
<div class="line">            <a class="code" href="classwx_message_output_debug.html" title="Output messages to the system debug output channel.">wxMessageOutputDebug</a>().<a class="code" href="classwx_message_output.html#a233e76ce6c1b569f16b42b49151ab979" title="Output a message.">Printf</a>(<span class="stringliteral">&quot;MYFRAME: deleting thread&quot;</span>);</div>
<div class="line"></div>
<div class="line">            <span class="keywordflow">if</span> (m_pThread-&gt;Delete() != <a class="code" href="interface_2wx_2thread_8h.html#a9e4ba0577f752fee0ba2133035f75ac2ad1525fe128b4989cb43a7e8112ac1b13" title="No error.">wxTHREAD_NO_ERROR</a> )</div>
<div class="line">                <a class="code" href="group__group__funcmacro__log.html#ga0dd3c633f990f794e76065c9a7af4c87" title="The functions to use for error messages, i.e.">wxLogError</a>(<span class="stringliteral">&quot;Can&#39;t delete the thread!&quot;</span>);</div>
<div class="line">        }</div>
<div class="line">    }       <span class="comment">// exit from the critical section to give the thread</span></div>
<div class="line">            <span class="comment">// the possibility to enter its destructor</span></div>
<div class="line">            <span class="comment">// (which is guarded with m_pThreadCS critical section!)</span></div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">while</span> (1)</div>
<div class="line">    {</div>
<div class="line">        { <span class="comment">// was the ~MyThread() function executed?</span></div>
<div class="line">            <a class="code" href="classwx_critical_section_locker.html" title="This is a small helper class to be used with wxCriticalSection objects.">wxCriticalSectionLocker</a> enter(m_pThreadCS);</div>
<div class="line">            <span class="keywordflow">if</span> (!m_pThread) <span class="keywordflow">break</span>;</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="comment">// wait for thread completion</span></div>
<div class="line">        <a class="code" href="classwx_thread.html#a7077fa46ffef0fd1d023628776598335" title="Return the thread object for the calling thread.">wxThread::This</a>()-&gt;<a class="code" href="classwx_thread.html#a9ae47b39270c54dba5534af31f885ec6" title="Pauses the thread execution for the given amount of time.">Sleep</a>(1);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    Destroy();</div>
<div class="line">}</div>
</div><!-- fragment --><p>For a more detailed and comprehensive example, see <a class="el" href="page_samples.html#page_samples_thread">Thread Sample</a>. For a simpler way to share data and synchronization objects between the main and the secondary thread see <a class="el" href="classwx_thread_helper.html" title="The wxThreadHelper class is a mix-in class that manages a single background thread, either detached or joinable (see wxThread for the differences).">wxThreadHelper</a>.</p>
<p>Conversely, <b>joinable</b> threads do not delete themselves when they are done processing and as such are safe to create on the stack. Joinable threads also provide the ability for one to get value it returned from <a class="el" href="classwx_thread.html#af50fa7d3ac55002e367e79989b9cbc5d" title="This is the entry point of the thread.">Entry()</a> through <a class="el" href="classwx_thread.html#a62ee778033013d3a4754b71b8cf2902e" title="Waits for a joinable thread to terminate and returns the value the thread returned from Entry() or &quot;(...">Wait()</a>. You shouldn't hurry to create all the threads joinable, however, because this has a disadvantage as well: you <b>must</b> <a class="el" href="classwx_thread.html#a62ee778033013d3a4754b71b8cf2902e" title="Waits for a joinable thread to terminate and returns the value the thread returned from Entry() or &quot;(...">Wait()</a> for a joinable thread or the system resources used by it will never be freed, and you also must delete the corresponding <a class="el" href="classwx_thread.html" title="A thread is basically a path of execution through a program.">wxThread</a> object yourself if you did not create it on the stack. In contrast, detached threads are of the "fire-and-forget" kind: you only have to start a detached thread and it will terminate and destroy itself.</p>
<h1><a class="anchor" id="thread_deletion"></a>
wxThread Deletion</h1>
<p>Regardless of whether it has terminated or not, you should call <a class="el" href="classwx_thread.html#a62ee778033013d3a4754b71b8cf2902e" title="Waits for a joinable thread to terminate and returns the value the thread returned from Entry() or &quot;(...">Wait()</a> on a <b>joinable</b> thread to release its memory, as outlined in <a class="el" href="classwx_thread.html#thread_types">Types of wxThreads</a>. If you created a joinable thread on the heap, remember to delete it manually with the <code>delete</code> operator or similar means as only detached threads handle this type of memory management.</p>
<p>Since <b>detached</b> threads delete themselves when they are finished processing, you should take care when calling a routine on one. If you are certain the thread is still running and would like to end it, you may call <a class="el" href="classwx_thread.html#a66796042bf5f3eb33a0ad3db85f686d4" title="Calling Delete() gracefully terminates a detached thread, either when the thread calls TestDestroy() ...">Delete()</a> to gracefully end it (which implies that the thread will be deleted after that call to <a class="el" href="classwx_thread.html#a66796042bf5f3eb33a0ad3db85f686d4" title="Calling Delete() gracefully terminates a detached thread, either when the thread calls TestDestroy() ...">Delete()</a>). It should be implied that you should <b>never</b> attempt to delete a detached thread with the <code>delete</code> operator or similar means.</p>
<p>As mentioned, <a class="el" href="classwx_thread.html#a62ee778033013d3a4754b71b8cf2902e" title="Waits for a joinable thread to terminate and returns the value the thread returned from Entry() or &quot;(...">Wait()</a> or <a class="el" href="classwx_thread.html#a66796042bf5f3eb33a0ad3db85f686d4" title="Calling Delete() gracefully terminates a detached thread, either when the thread calls TestDestroy() ...">Delete()</a> functions attempt to gracefully terminate a joinable and a detached thread, respectively. They do this by waiting until the thread in question calls <a class="el" href="classwx_thread.html#a9a3acec44b06b2a2430c5659991a3eac" title="This function should be called periodically by the thread to ensure that calls to Pause() and Delete(...">TestDestroy()</a> or ends processing (i.e. returns from <a class="el" href="classwx_thread.html#af50fa7d3ac55002e367e79989b9cbc5d" title="This is the entry point of the thread.">wxThread::Entry</a>).</p>
<p>Obviously, if the thread does call <a class="el" href="classwx_thread.html#a9a3acec44b06b2a2430c5659991a3eac" title="This function should be called periodically by the thread to ensure that calls to Pause() and Delete(...">TestDestroy()</a> and does not end, the thread which called <a class="el" href="classwx_thread.html#a62ee778033013d3a4754b71b8cf2902e" title="Waits for a joinable thread to terminate and returns the value the thread returned from Entry() or &quot;(...">Wait()</a> or <a class="el" href="classwx_thread.html#a66796042bf5f3eb33a0ad3db85f686d4" title="Calling Delete() gracefully terminates a detached thread, either when the thread calls TestDestroy() ...">Delete()</a> will come to halt. This is why it's important to call <a class="el" href="classwx_thread.html#a9a3acec44b06b2a2430c5659991a3eac" title="This function should be called periodically by the thread to ensure that calls to Pause() and Delete(...">TestDestroy()</a> in the <a class="el" href="classwx_thread.html#af50fa7d3ac55002e367e79989b9cbc5d" title="This is the entry point of the thread.">Entry()</a> routine of your threads as often as possible and immediately exit when it returns <span class="literal">true</span>.</p>
<p>As a last resort you can end the thread immediately through <a class="el" href="classwx_thread.html#a2cbff8b3b0a93ab82f212c02f38a1ef4" title="Immediately terminates the target thread.">Kill()</a>. It is strongly recommended that you do not do this, however, as it does not free the resources associated with the object (although the <a class="el" href="classwx_thread.html" title="A thread is basically a path of execution through a program.">wxThread</a> object of detached threads will still be deleted) and could leave the C runtime library in an undefined state.</p>
<h1><a class="anchor" id="thread_secondary"></a>
wxWidgets Calls in Secondary Threads</h1>
<p>All threads other than the "main application thread" (the one running <a class="el" href="classwx_app_console.html#a99953775a2fd83fa2456e390779afe15" title="This must be provided by the application, and will usually create the application&#39;s main window...">wxApp::OnInit()</a> or the one your main function runs in, for example) are considered "secondary threads".</p>
<p>GUI calls, such as those to a <a class="el" href="classwx_window.html" title="wxWindow is the base class for all windows and represents any visible object on screen.">wxWindow</a> or <a class="el" href="classwx_bitmap.html" title="This class encapsulates the concept of a platform-dependent bitmap, either monochrome or colour or co...">wxBitmap</a> are explicitly not safe at all in secondary threads and could end your application prematurely. This is due to several reasons, including the underlying native API and the fact that <a class="el" href="classwx_thread.html" title="A thread is basically a path of execution through a program.">wxThread</a> does not run a GUI event loop similar to other APIs as MFC.</p>
<p>A workaround for some wxWidgets ports is calling wxMutexGUIEnter() before any GUI calls and then calling wxMutexGUILeave() afterwords. However, the recommended way is to simply process the GUI calls in the main thread through an event that is posted by <a class="el" href="group__group__funcmacro__events.html#gae921d7bd0e52fedbf3f253d2c408bce1" title="Queue an event for processing on the given object.">wxQueueEvent()</a>. This does not imply that calls to these classes are thread-safe, however, as most wxWidgets classes are not thread-safe, including <a class="el" href="classwx_string.html" title="String class for passing textual data to or receiving it from wxWidgets.">wxString</a>.</p>
<h1><a class="anchor" id="thread_poll"></a>
Don't Poll a wxThread</h1>
<p>A common problem users experience with <a class="el" href="classwx_thread.html" title="A thread is basically a path of execution through a program.">wxThread</a> is that in their main thread they will check the thread every now and then to see if it has ended through <a class="el" href="classwx_thread.html#a0230733ffdc8f7603082dd2ca86b8cdd" title="Returns true if the thread is running.">IsRunning()</a>, only to find that their application has run into problems because the thread is using the default behaviour (i.e. it's <b>detached</b>) and has already deleted itself. Naturally, they instead attempt to use joinable threads in place of the previous behaviour. However, polling a <a class="el" href="classwx_thread.html" title="A thread is basically a path of execution through a program.">wxThread</a> for when it has ended is in general a bad idea - in fact calling a routine on any running <a class="el" href="classwx_thread.html" title="A thread is basically a path of execution through a program.">wxThread</a> should be avoided if possible. Instead, find a way to notify yourself when the thread has ended.</p>
<p>Usually you only need to notify the main thread, in which case you can post an event to it via <a class="el" href="group__group__funcmacro__events.html#gae921d7bd0e52fedbf3f253d2c408bce1" title="Queue an event for processing on the given object.">wxQueueEvent()</a>. In the case of secondary threads you can call a routine of another class when the thread is about to complete processing and/or set the value of a variable, possibly using mutexes (see <a class="el" href="classwx_mutex.html" title="A mutex object is a synchronization object whose state is set to signaled when it is not owned by any...">wxMutex</a>) and/or other synchronization means if necessary.</p>
<h2></h2>
<div><span class="lib">Library:</span>&#160;&#160;<span class="lib_text"><a class="el" href="page_libs.html#page_libs_wxbase">wxBase</a></span></div><div><span class="category">Category:</span>&#160;&#160;<span class="category_text"><a class="el" href="group__group__class__threading.html">Threading</a></span></div><dl class="section see"><dt>See Also</dt><dd><a class="el" href="classwx_thread_helper.html" title="The wxThreadHelper class is a mix-in class that manages a single background thread, either detached or joinable (see wxThread for the differences).">wxThreadHelper</a>, <a class="el" href="classwx_mutex.html" title="A mutex object is a synchronization object whose state is set to signaled when it is not owned by any...">wxMutex</a>, <a class="el" href="classwx_condition.html" title="wxCondition variables correspond to pthread conditions or to Win32 event objects.">wxCondition</a>, <a class="el" href="classwx_critical_section.html" title="A critical section object is used for exactly the same purpose as a wxMutex.">wxCriticalSection</a>, <a class="el" href="overview_thread.html">Multithreading Overview</a> </dd></dl>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:ade9497fa072fe19481086e6486dcc028"><td class="memItemLeft" align="right" valign="top">typedef void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwx_thread.html#ade9497fa072fe19481086e6486dcc028">ExitCode</a></td></tr>
<tr class="memdesc:ade9497fa072fe19481086e6486dcc028"><td class="mdescLeft">&#160;</td><td class="mdescRight">The return type for the thread functions.  <a href="#ade9497fa072fe19481086e6486dcc028"></a><br/></td></tr>
<tr class="separator:ade9497fa072fe19481086e6486dcc028"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aafdb64801bd4d595ad0956f71d5791f0"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwx_thread.html#aafdb64801bd4d595ad0956f71d5791f0">wxThread</a> (<a class="el" href="interface_2wx_2thread_8h.html#a0dc9a167e8d084946512da99b37b5fd0">wxThreadKind</a> kind=<a class="el" href="interface_2wx_2thread_8h.html#a0dc9a167e8d084946512da99b37b5fd0acd9af5dbbc12a95684ab6e7be16e30c9">wxTHREAD_DETACHED</a>)</td></tr>
<tr class="memdesc:aafdb64801bd4d595ad0956f71d5791f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">This constructor creates a new detached (default) or joinable C++ thread object.  <a href="#aafdb64801bd4d595ad0956f71d5791f0"></a><br/></td></tr>
<tr class="separator:aafdb64801bd4d595ad0956f71d5791f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48c37f3555eb99cca9d9f3594fed5793"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwx_thread.html#a48c37f3555eb99cca9d9f3594fed5793">~wxThread</a> ()</td></tr>
<tr class="memdesc:a48c37f3555eb99cca9d9f3594fed5793"><td class="mdescLeft">&#160;</td><td class="mdescRight">The destructor frees the resources associated with the thread.  <a href="#a48c37f3555eb99cca9d9f3594fed5793"></a><br/></td></tr>
<tr class="separator:a48c37f3555eb99cca9d9f3594fed5793"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88051a33aa3fa9ca9392ac7d47b43cf4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="interface_2wx_2thread_8h.html#a9e4ba0577f752fee0ba2133035f75ac2">wxThreadError</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwx_thread.html#a88051a33aa3fa9ca9392ac7d47b43cf4">Create</a> (unsigned int stackSize=0)</td></tr>
<tr class="memdesc:a88051a33aa3fa9ca9392ac7d47b43cf4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new thread.  <a href="#a88051a33aa3fa9ca9392ac7d47b43cf4"></a><br/></td></tr>
<tr class="separator:a88051a33aa3fa9ca9392ac7d47b43cf4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66796042bf5f3eb33a0ad3db85f686d4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="interface_2wx_2thread_8h.html#a9e4ba0577f752fee0ba2133035f75ac2">wxThreadError</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwx_thread.html#a66796042bf5f3eb33a0ad3db85f686d4">Delete</a> (<a class="el" href="classwx_thread.html#ade9497fa072fe19481086e6486dcc028">ExitCode</a> *rc=NULL, <a class="el" href="interface_2wx_2thread_8h.html#a180bd0d42ba227657c3ad00194371a87">wxThreadWait</a> waitMode=<a class="el" href="interface_2wx_2thread_8h.html#a180bd0d42ba227657c3ad00194371a87a47788167d370686ccade7904df7296f0">wxTHREAD_WAIT_BLOCK</a>)</td></tr>
<tr class="memdesc:a66796042bf5f3eb33a0ad3db85f686d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calling <a class="el" href="classwx_thread.html#a66796042bf5f3eb33a0ad3db85f686d4" title="Calling Delete() gracefully terminates a detached thread, either when the thread calls TestDestroy() ...">Delete()</a> gracefully terminates a <b>detached</b> thread, either when the thread calls <a class="el" href="classwx_thread.html#a9a3acec44b06b2a2430c5659991a3eac" title="This function should be called periodically by the thread to ensure that calls to Pause() and Delete(...">TestDestroy()</a> or when it finishes processing.  <a href="#a66796042bf5f3eb33a0ad3db85f686d4"></a><br/></td></tr>
<tr class="separator:a66796042bf5f3eb33a0ad3db85f686d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c9db3ca1d37d8ed921e78c31acd9bb4"><td class="memItemLeft" align="right" valign="top">wxThreadIdType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwx_thread.html#a2c9db3ca1d37d8ed921e78c31acd9bb4">GetId</a> () const </td></tr>
<tr class="memdesc:a2c9db3ca1d37d8ed921e78c31acd9bb4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the thread identifier: this is a platform dependent number that uniquely identifies the thread throughout the system during its existence (i.e. the thread identifiers may be reused).  <a href="#a2c9db3ca1d37d8ed921e78c31acd9bb4"></a><br/></td></tr>
<tr class="separator:a2c9db3ca1d37d8ed921e78c31acd9bb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fc5fa753cf2bc0ec63ff16825a144b2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="interface_2wx_2thread_8h.html#a0dc9a167e8d084946512da99b37b5fd0">wxThreadKind</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwx_thread.html#a1fc5fa753cf2bc0ec63ff16825a144b2">GetKind</a> () const </td></tr>
<tr class="memdesc:a1fc5fa753cf2bc0ec63ff16825a144b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the thread kind as it was given in the ctor.  <a href="#a1fc5fa753cf2bc0ec63ff16825a144b2"></a><br/></td></tr>
<tr class="separator:a1fc5fa753cf2bc0ec63ff16825a144b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a785ac6add565d789481f8a9dfde5c229"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwx_thread.html#a785ac6add565d789481f8a9dfde5c229">GetPriority</a> () const </td></tr>
<tr class="memdesc:a785ac6add565d789481f8a9dfde5c229"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the priority of the thread, between 0 (lowest) and 100 (highest).  <a href="#a785ac6add565d789481f8a9dfde5c229"></a><br/></td></tr>
<tr class="separator:a785ac6add565d789481f8a9dfde5c229"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc6cf71c426b1da03c6ca4b7f7da8aab"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwx_thread.html#adc6cf71c426b1da03c6ca4b7f7da8aab">IsAlive</a> () const </td></tr>
<tr class="memdesc:adc6cf71c426b1da03c6ca4b7f7da8aab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <span class="literal">true</span> if the thread is alive (i.e. started and not terminating).  <a href="#adc6cf71c426b1da03c6ca4b7f7da8aab"></a><br/></td></tr>
<tr class="separator:adc6cf71c426b1da03c6ca4b7f7da8aab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a315c2abb553ba7e17ab2d5b2a0728e73"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwx_thread.html#a315c2abb553ba7e17ab2d5b2a0728e73">IsDetached</a> () const </td></tr>
<tr class="memdesc:a315c2abb553ba7e17ab2d5b2a0728e73"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <span class="literal">true</span> if the thread is of the detached kind, <span class="literal">false</span> if it is a joinable one.  <a href="#a315c2abb553ba7e17ab2d5b2a0728e73"></a><br/></td></tr>
<tr class="separator:a315c2abb553ba7e17ab2d5b2a0728e73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34328ecb720a1066971fb5e48cd84b6f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwx_thread.html#a34328ecb720a1066971fb5e48cd84b6f">IsPaused</a> () const </td></tr>
<tr class="memdesc:a34328ecb720a1066971fb5e48cd84b6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <span class="literal">true</span> if the thread is paused.  <a href="#a34328ecb720a1066971fb5e48cd84b6f"></a><br/></td></tr>
<tr class="separator:a34328ecb720a1066971fb5e48cd84b6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0230733ffdc8f7603082dd2ca86b8cdd"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwx_thread.html#a0230733ffdc8f7603082dd2ca86b8cdd">IsRunning</a> () const </td></tr>
<tr class="memdesc:a0230733ffdc8f7603082dd2ca86b8cdd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <span class="literal">true</span> if the thread is running.  <a href="#a0230733ffdc8f7603082dd2ca86b8cdd"></a><br/></td></tr>
<tr class="separator:a0230733ffdc8f7603082dd2ca86b8cdd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cbff8b3b0a93ab82f212c02f38a1ef4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="interface_2wx_2thread_8h.html#a9e4ba0577f752fee0ba2133035f75ac2">wxThreadError</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwx_thread.html#a2cbff8b3b0a93ab82f212c02f38a1ef4">Kill</a> ()</td></tr>
<tr class="memdesc:a2cbff8b3b0a93ab82f212c02f38a1ef4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Immediately terminates the target thread.  <a href="#a2cbff8b3b0a93ab82f212c02f38a1ef4"></a><br/></td></tr>
<tr class="separator:a2cbff8b3b0a93ab82f212c02f38a1ef4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c6d835578dde71dd2c241c38336a4ba"><td class="memItemLeft" align="right" valign="top"><a class="el" href="interface_2wx_2thread_8h.html#a9e4ba0577f752fee0ba2133035f75ac2">wxThreadError</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwx_thread.html#a8c6d835578dde71dd2c241c38336a4ba">Pause</a> ()</td></tr>
<tr class="memdesc:a8c6d835578dde71dd2c241c38336a4ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Suspends the thread.  <a href="#a8c6d835578dde71dd2c241c38336a4ba"></a><br/></td></tr>
<tr class="separator:a8c6d835578dde71dd2c241c38336a4ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe81d37cd6cb6d5eb142773fb2c94562"><td class="memItemLeft" align="right" valign="top"><a class="el" href="interface_2wx_2thread_8h.html#a9e4ba0577f752fee0ba2133035f75ac2">wxThreadError</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwx_thread.html#afe81d37cd6cb6d5eb142773fb2c94562">Resume</a> ()</td></tr>
<tr class="memdesc:afe81d37cd6cb6d5eb142773fb2c94562"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resumes a thread suspended by the call to <a class="el" href="classwx_thread.html#a8c6d835578dde71dd2c241c38336a4ba" title="Suspends the thread.">Pause()</a>.  <a href="#afe81d37cd6cb6d5eb142773fb2c94562"></a><br/></td></tr>
<tr class="separator:afe81d37cd6cb6d5eb142773fb2c94562"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d894750ffaac8fc42ee85aeff8bb4c0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="interface_2wx_2thread_8h.html#a9e4ba0577f752fee0ba2133035f75ac2">wxThreadError</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwx_thread.html#a5d894750ffaac8fc42ee85aeff8bb4c0">Run</a> ()</td></tr>
<tr class="memdesc:a5d894750ffaac8fc42ee85aeff8bb4c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Starts the thread execution.  <a href="#a5d894750ffaac8fc42ee85aeff8bb4c0"></a><br/></td></tr>
<tr class="separator:a5d894750ffaac8fc42ee85aeff8bb4c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6236828fe98e81103219a519fbd7091d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwx_thread.html#a6236828fe98e81103219a519fbd7091d">SetPriority</a> (unsigned int priority)</td></tr>
<tr class="memdesc:a6236828fe98e81103219a519fbd7091d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the priority of the thread, between 0 (lowest) and 100 (highest).  <a href="#a6236828fe98e81103219a519fbd7091d"></a><br/></td></tr>
<tr class="separator:a6236828fe98e81103219a519fbd7091d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a3acec44b06b2a2430c5659991a3eac"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwx_thread.html#a9a3acec44b06b2a2430c5659991a3eac">TestDestroy</a> ()</td></tr>
<tr class="memdesc:a9a3acec44b06b2a2430c5659991a3eac"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function should be called periodically by the thread to ensure that calls to <a class="el" href="classwx_thread.html#a8c6d835578dde71dd2c241c38336a4ba" title="Suspends the thread.">Pause()</a> and <a class="el" href="classwx_thread.html#a66796042bf5f3eb33a0ad3db85f686d4" title="Calling Delete() gracefully terminates a detached thread, either when the thread calls TestDestroy() ...">Delete()</a> will work.  <a href="#a9a3acec44b06b2a2430c5659991a3eac"></a><br/></td></tr>
<tr class="separator:a9a3acec44b06b2a2430c5659991a3eac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62ee778033013d3a4754b71b8cf2902e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classwx_thread.html#ade9497fa072fe19481086e6486dcc028">ExitCode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwx_thread.html#a62ee778033013d3a4754b71b8cf2902e">Wait</a> (<a class="el" href="interface_2wx_2thread_8h.html#a180bd0d42ba227657c3ad00194371a87">wxThreadWait</a> flags=<a class="el" href="interface_2wx_2thread_8h.html#a180bd0d42ba227657c3ad00194371a87a47788167d370686ccade7904df7296f0">wxTHREAD_WAIT_BLOCK</a>)</td></tr>
<tr class="memdesc:a62ee778033013d3a4754b71b8cf2902e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Waits for a <b>joinable</b> thread to terminate and returns the value the thread returned from <a class="el" href="classwx_thread.html#af50fa7d3ac55002e367e79989b9cbc5d" title="This is the entry point of the thread.">Entry()</a> or <code>"(ExitCode)-1"</code> on error.  <a href="#a62ee778033013d3a4754b71b8cf2902e"></a><br/></td></tr>
<tr class="separator:a62ee778033013d3a4754b71b8cf2902e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a21ccbc2f91bed8d65aeada49a7f8335d"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwx_thread.html#a21ccbc2f91bed8d65aeada49a7f8335d">GetCPUCount</a> ()</td></tr>
<tr class="memdesc:a21ccbc2f91bed8d65aeada49a7f8335d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of system CPUs or -1 if the value is unknown.  <a href="#a21ccbc2f91bed8d65aeada49a7f8335d"></a><br/></td></tr>
<tr class="separator:a21ccbc2f91bed8d65aeada49a7f8335d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a414fecfb855a7e12088bb0fa54ebd330"><td class="memItemLeft" align="right" valign="top">static wxThreadIdType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwx_thread.html#a414fecfb855a7e12088bb0fa54ebd330">GetCurrentId</a> ()</td></tr>
<tr class="memdesc:a414fecfb855a7e12088bb0fa54ebd330"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the platform specific thread ID of the current thread as a long.  <a href="#a414fecfb855a7e12088bb0fa54ebd330"></a><br/></td></tr>
<tr class="separator:a414fecfb855a7e12088bb0fa54ebd330"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0023e6e671b016f06c452f34dd6ce8f4"><td class="memItemLeft" align="right" valign="top">static wxThreadIdType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwx_thread.html#a0023e6e671b016f06c452f34dd6ce8f4">GetMainId</a> ()</td></tr>
<tr class="memdesc:a0023e6e671b016f06c452f34dd6ce8f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the thread ID of the main thread.  <a href="#a0023e6e671b016f06c452f34dd6ce8f4"></a><br/></td></tr>
<tr class="separator:a0023e6e671b016f06c452f34dd6ce8f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ee917ef87f986ba3b2ee26e620378e4"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwx_thread.html#a1ee917ef87f986ba3b2ee26e620378e4">IsMain</a> ()</td></tr>
<tr class="memdesc:a1ee917ef87f986ba3b2ee26e620378e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <span class="literal">true</span> if the calling thread is the main application thread.  <a href="#a1ee917ef87f986ba3b2ee26e620378e4"></a><br/></td></tr>
<tr class="separator:a1ee917ef87f986ba3b2ee26e620378e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09dfe3800bbfad53be303a4608d52959"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwx_thread.html#a09dfe3800bbfad53be303a4608d52959">SetConcurrency</a> (size_t level)</td></tr>
<tr class="memdesc:a09dfe3800bbfad53be303a4608d52959"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the thread concurrency level for this process.  <a href="#a09dfe3800bbfad53be303a4608d52959"></a><br/></td></tr>
<tr class="separator:a09dfe3800bbfad53be303a4608d52959"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ae47b39270c54dba5534af31f885ec6"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwx_thread.html#a9ae47b39270c54dba5534af31f885ec6">Sleep</a> (unsigned long milliseconds)</td></tr>
<tr class="memdesc:a9ae47b39270c54dba5534af31f885ec6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pauses the thread execution for the given amount of time.  <a href="#a9ae47b39270c54dba5534af31f885ec6"></a><br/></td></tr>
<tr class="separator:a9ae47b39270c54dba5534af31f885ec6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7077fa46ffef0fd1d023628776598335"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classwx_thread.html">wxThread</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwx_thread.html#a7077fa46ffef0fd1d023628776598335">This</a> ()</td></tr>
<tr class="memdesc:a7077fa46ffef0fd1d023628776598335"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the thread object for the calling thread.  <a href="#a7077fa46ffef0fd1d023628776598335"></a><br/></td></tr>
<tr class="separator:a7077fa46ffef0fd1d023628776598335"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a36099bab2d4be9d72cfd4cf76e8aa6"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwx_thread.html#a7a36099bab2d4be9d72cfd4cf76e8aa6">Yield</a> ()</td></tr>
<tr class="memdesc:a7a36099bab2d4be9d72cfd4cf76e8aa6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Give the rest of the thread's time-slice to the system allowing the other threads to run.  <a href="#a7a36099bab2d4be9d72cfd4cf76e8aa6"></a><br/></td></tr>
<tr class="separator:a7a36099bab2d4be9d72cfd4cf76e8aa6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:af50fa7d3ac55002e367e79989b9cbc5d"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classwx_thread.html#ade9497fa072fe19481086e6486dcc028">ExitCode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwx_thread.html#af50fa7d3ac55002e367e79989b9cbc5d">Entry</a> ()=0</td></tr>
<tr class="memdesc:af50fa7d3ac55002e367e79989b9cbc5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the entry point of the thread.  <a href="#af50fa7d3ac55002e367e79989b9cbc5d"></a><br/></td></tr>
<tr class="separator:af50fa7d3ac55002e367e79989b9cbc5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a888b9b94f64a2b61bd4740de1149e6e2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwx_thread.html#a888b9b94f64a2b61bd4740de1149e6e2">Exit</a> (<a class="el" href="classwx_thread.html#ade9497fa072fe19481086e6486dcc028">ExitCode</a> exitcode=0)</td></tr>
<tr class="memdesc:a888b9b94f64a2b61bd4740de1149e6e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a protected function of the <a class="el" href="classwx_thread.html" title="A thread is basically a path of execution through a program.">wxThread</a> class and thus can only be called from a derived class.  <a href="#a888b9b94f64a2b61bd4740de1149e6e2"></a><br/></td></tr>
<tr class="separator:a888b9b94f64a2b61bd4740de1149e6e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Typedef Documentation</h2>
<a class="anchor" id="ade9497fa072fe19481086e6486dcc028"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void* <a class="el" href="classwx_thread.html#ade9497fa072fe19481086e6486dcc028">wxThread::ExitCode</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The return type for the thread functions. </p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="aafdb64801bd4d595ad0956f71d5791f0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">wxThread::wxThread </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="interface_2wx_2thread_8h.html#a0dc9a167e8d084946512da99b37b5fd0">wxThreadKind</a>&#160;</td>
          <td class="paramname"><em>kind</em> = <code><a class="el" href="interface_2wx_2thread_8h.html#a0dc9a167e8d084946512da99b37b5fd0acd9af5dbbc12a95684ab6e7be16e30c9">wxTHREAD_DETACHED</a></code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This constructor creates a new detached (default) or joinable C++ thread object. </p>
<p>It does not create or start execution of the real thread - for this you should use the <a class="el" href="classwx_thread.html#a5d894750ffaac8fc42ee85aeff8bb4c0" title="Starts the thread execution.">Run()</a> method.</p>
<p>The possible values for <em>kind</em> parameters are:</p>
<ul>
<li><b>wxTHREAD_DETACHED</b> - Creates a detached thread.</li>
<li><b>wxTHREAD_JOINABLE</b> - Creates a joinable thread. </li>
</ul>

</div>
</div>
<a class="anchor" id="a48c37f3555eb99cca9d9f3594fed5793"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual wxThread::~wxThread </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The destructor frees the resources associated with the thread. </p>
<p>Notice that you should never delete a detached thread &ndash; you may only call <a class="el" href="classwx_thread.html#a66796042bf5f3eb33a0ad3db85f686d4" title="Calling Delete() gracefully terminates a detached thread, either when the thread calls TestDestroy() ...">Delete()</a> on it or wait until it terminates (and auto destructs) itself.</p>
<p>Because the detached threads delete themselves, they can only be allocated on the heap. Joinable threads should be deleted explicitly. The <a class="el" href="classwx_thread.html#a66796042bf5f3eb33a0ad3db85f686d4" title="Calling Delete() gracefully terminates a detached thread, either when the thread calls TestDestroy() ...">Delete()</a> and <a class="el" href="classwx_thread.html#a2cbff8b3b0a93ab82f212c02f38a1ef4" title="Immediately terminates the target thread.">Kill()</a> functions will not delete the C++ thread object. It is also safe to allocate them on stack. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a88051a33aa3fa9ca9392ac7d47b43cf4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="interface_2wx_2thread_8h.html#a9e4ba0577f752fee0ba2133035f75ac2">wxThreadError</a> wxThread::Create </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>stackSize</em> = <code>0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new thread. </p>
<p>The thread object is created in the suspended state, and you should call <a class="el" href="classwx_thread.html#a5d894750ffaac8fc42ee85aeff8bb4c0" title="Starts the thread execution.">Run()</a> to start running it. You may optionally specify the stack size to be allocated to it (Ignored on platforms that don't support setting it explicitly, eg. Unix system without <code>pthread_attr_setstacksize</code>).</p>
<p>If you do not specify the stack size, the system's default value is used.</p>
<dl class="section note"><dt>Note</dt><dd>It is not necessary to call this method since 2.9.5, <a class="el" href="classwx_thread.html#a5d894750ffaac8fc42ee85aeff8bb4c0" title="Starts the thread execution.">Run()</a> will create the thread internally. You only need to call <a class="el" href="classwx_thread.html#a88051a33aa3fa9ca9392ac7d47b43cf4" title="Creates a new thread.">Create()</a> if you need to do something with the thread (e.g. pass its ID to an external library) before it starts.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>It is a good idea to explicitly specify a value as systems' default values vary from just a couple of KB on some systems (BSD and OS/2 systems) to one or several MB (Windows, Solaris, Linux). So, if you have a thread that requires more than just a few KB of memory, you will have mysterious problems on some platforms but not on the common ones. On the other hand, just indicating a large stack size by default will give you performance issues on those systems with small default stack since those typically use fully committed memory for the stack. On the contrary, if you use a lot of threads (say several hundred), virtual address space can get tight unless you explicitly specify a smaller amount of thread stack space for each thread.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>One of:<ul>
<li><b>wxTHREAD_NO_ERROR</b> - No error.</li>
<li><b>wxTHREAD_NO_RESOURCE</b> - There were insufficient resources to create the thread.</li>
<li><b>wxTHREAD_NO_RUNNING</b> - The thread is already running </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a66796042bf5f3eb33a0ad3db85f686d4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="interface_2wx_2thread_8h.html#a9e4ba0577f752fee0ba2133035f75ac2">wxThreadError</a> wxThread::Delete </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classwx_thread.html#ade9497fa072fe19481086e6486dcc028">ExitCode</a> *&#160;</td>
          <td class="paramname"><em>rc</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="interface_2wx_2thread_8h.html#a180bd0d42ba227657c3ad00194371a87">wxThreadWait</a>&#160;</td>
          <td class="paramname"><em>waitMode</em> = <code><a class="el" href="interface_2wx_2thread_8h.html#a180bd0d42ba227657c3ad00194371a87a47788167d370686ccade7904df7296f0">wxTHREAD_WAIT_BLOCK</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calling <a class="el" href="classwx_thread.html#a66796042bf5f3eb33a0ad3db85f686d4" title="Calling Delete() gracefully terminates a detached thread, either when the thread calls TestDestroy() ...">Delete()</a> gracefully terminates a <b>detached</b> thread, either when the thread calls <a class="el" href="classwx_thread.html#a9a3acec44b06b2a2430c5659991a3eac" title="This function should be called periodically by the thread to ensure that calls to Pause() and Delete(...">TestDestroy()</a> or when it finishes processing. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rc</td><td>The thread exit code, if rc is not NULL.</td></tr>
    <tr><td class="paramname">waitMode</td><td>As described in wxThreadWait documentation, wxTHREAD_WAIT_BLOCK should be used as the wait mode even although currently wxTHREAD_WAIT_YIELD is for compatibility reasons. This parameter is new in wxWidgets 2.9.2.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function works on a joinable thread but in that case makes the <a class="el" href="classwx_thread.html#a9a3acec44b06b2a2430c5659991a3eac" title="This function should be called periodically by the thread to ensure that calls to Pause() and Delete(...">TestDestroy()</a> function of the thread return <span class="literal">true</span> and then waits for its completion (i.e. it differs from <a class="el" href="classwx_thread.html#a62ee778033013d3a4754b71b8cf2902e" title="Waits for a joinable thread to terminate and returns the value the thread returned from Entry() or &quot;(...">Wait()</a> because it asks the thread to terminate before waiting).</dd></dl>
<p>See <a class="el" href="classwx_thread.html#thread_deletion">wxThread Deletion</a> for a broader explanation of this routine. </p>

</div>
</div>
<a class="anchor" id="af50fa7d3ac55002e367e79989b9cbc5d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classwx_thread.html#ade9497fa072fe19481086e6486dcc028">ExitCode</a> wxThread::Entry </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This is the entry point of the thread. </p>
<p>This function is pure virtual and must be implemented by any derived class. The thread execution will start here.</p>
<p>The returned value is the thread exit code which is only useful for joinable threads and is the value returned by <a class="el" href="classwx_thread.html#a62ee778033013d3a4754b71b8cf2902e" title="Waits for a joinable thread to terminate and returns the value the thread returned from Entry() or &quot;(...">Wait()</a>. This function is called by wxWidgets itself and should never be called directly. </p>

</div>
</div>
<a class="anchor" id="a888b9b94f64a2b61bd4740de1149e6e2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void wxThread::Exit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classwx_thread.html#ade9497fa072fe19481086e6486dcc028">ExitCode</a>&#160;</td>
          <td class="paramname"><em>exitcode</em> = <code>0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This is a protected function of the <a class="el" href="classwx_thread.html" title="A thread is basically a path of execution through a program.">wxThread</a> class and thus can only be called from a derived class. </p>
<p>It also can only be called in the context of this thread, i.e. a thread can only exit from itself, not from another thread.</p>
<p>This function will terminate the OS thread (i.e. stop the associated path of execution) and also delete the associated C++ object for detached threads. OnExit() will be called just before exiting. </p>

</div>
</div>
<a class="anchor" id="a21ccbc2f91bed8d65aeada49a7f8335d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int wxThread::GetCPUCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of system CPUs or -1 if the value is unknown. </p>
<p>For multi-core systems the returned value is typically the total number of <em>cores</em>, since the OS usually abstract a single N-core CPU as N different cores.</p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="classwx_thread.html#a09dfe3800bbfad53be303a4608d52959" title="Sets the thread concurrency level for this process.">SetConcurrency()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a414fecfb855a7e12088bb0fa54ebd330"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static wxThreadIdType wxThread::GetCurrentId </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the platform specific thread ID of the current thread as a long. </p>
<p>This can be used to uniquely identify threads, even if they are not wxThreads.</p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="classwx_thread.html#a0023e6e671b016f06c452f34dd6ce8f4" title="Returns the thread ID of the main thread.">GetMainId()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a2c9db3ca1d37d8ed921e78c31acd9bb4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">wxThreadIdType wxThread::GetId </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the thread identifier: this is a platform dependent number that uniquely identifies the thread throughout the system during its existence (i.e. the thread identifiers may be reused). </p>

</div>
</div>
<a class="anchor" id="a1fc5fa753cf2bc0ec63ff16825a144b2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="interface_2wx_2thread_8h.html#a0dc9a167e8d084946512da99b37b5fd0">wxThreadKind</a> wxThread::GetKind </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the thread kind as it was given in the ctor. </p>
<dl class="section since"><dt>Since</dt><dd>2.9.0 </dd></dl>

</div>
</div>
<a class="anchor" id="a0023e6e671b016f06c452f34dd6ce8f4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static wxThreadIdType wxThread::GetMainId </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the thread ID of the main thread. </p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="classwx_thread.html#a1ee917ef87f986ba3b2ee26e620378e4" title="Returns true if the calling thread is the main application thread.">IsMain()</a></dd></dl>
<dl class="section since"><dt>Since</dt><dd>2.9.1 </dd></dl>

</div>
</div>
<a class="anchor" id="a785ac6add565d789481f8a9dfde5c229"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int wxThread::GetPriority </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the priority of the thread, between 0 (lowest) and 100 (highest). </p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="classwx_thread.html#a6236828fe98e81103219a519fbd7091d" title="Sets the priority of the thread, between 0 (lowest) and 100 (highest).">SetPriority()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="adc6cf71c426b1da03c6ca4b7f7da8aab"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool wxThread::IsAlive </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns <span class="literal">true</span> if the thread is alive (i.e. started and not terminating). </p>
<p>Note that this function can only safely be used with joinable threads, not detached ones as the latter delete themselves and so when the real thread is no longer alive, it is not possible to call this function because the <a class="el" href="classwx_thread.html" title="A thread is basically a path of execution through a program.">wxThread</a> object no longer exists. </p>

</div>
</div>
<a class="anchor" id="a315c2abb553ba7e17ab2d5b2a0728e73"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool wxThread::IsDetached </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns <span class="literal">true</span> if the thread is of the detached kind, <span class="literal">false</span> if it is a joinable one. </p>

</div>
</div>
<a class="anchor" id="a1ee917ef87f986ba3b2ee26e620378e4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool wxThread::IsMain </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns <span class="literal">true</span> if the calling thread is the main application thread. </p>
<p>Main thread in the context of wxWidgets is the one which initialized the library.</p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="classwx_thread.html#a0023e6e671b016f06c452f34dd6ce8f4" title="Returns the thread ID of the main thread.">GetMainId()</a>, <a class="el" href="classwx_thread.html#a414fecfb855a7e12088bb0fa54ebd330" title="Returns the platform specific thread ID of the current thread as a long.">GetCurrentId()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a34328ecb720a1066971fb5e48cd84b6f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool wxThread::IsPaused </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns <span class="literal">true</span> if the thread is paused. </p>

</div>
</div>
<a class="anchor" id="a0230733ffdc8f7603082dd2ca86b8cdd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool wxThread::IsRunning </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns <span class="literal">true</span> if the thread is running. </p>
<p>This method may only be safely used for joinable threads, see the remark in <a class="el" href="classwx_thread.html#adc6cf71c426b1da03c6ca4b7f7da8aab" title="Returns true if the thread is alive (i.e. started and not terminating).">IsAlive()</a>. </p>

</div>
</div>
<a class="anchor" id="a2cbff8b3b0a93ab82f212c02f38a1ef4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="interface_2wx_2thread_8h.html#a9e4ba0577f752fee0ba2133035f75ac2">wxThreadError</a> wxThread::Kill </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Immediately terminates the target thread. </p>
<p><b>"This function is dangerous and should be used with extreme care"</b> (and not used at all whenever possible)! The resources allocated to the thread will not be freed and the state of the C runtime library may become inconsistent. Use <a class="el" href="classwx_thread.html#a66796042bf5f3eb33a0ad3db85f686d4" title="Calling Delete() gracefully terminates a detached thread, either when the thread calls TestDestroy() ...">Delete()</a> for detached threads or <a class="el" href="classwx_thread.html#a62ee778033013d3a4754b71b8cf2902e" title="Waits for a joinable thread to terminate and returns the value the thread returned from Entry() or &quot;(...">Wait()</a> for joinable threads instead.</p>
<p>For detached threads <a class="el" href="classwx_thread.html#a2cbff8b3b0a93ab82f212c02f38a1ef4" title="Immediately terminates the target thread.">Kill()</a> will also delete the associated C++ object. However this will not happen for joinable threads and this means that you will still have to delete the <a class="el" href="classwx_thread.html" title="A thread is basically a path of execution through a program.">wxThread</a> object yourself to avoid memory leaks.</p>
<p>In neither case OnExit() of the dying thread will be called, so no thread-specific cleanup will be performed. This function can only be called from another thread context, i.e. a thread cannot kill itself.</p>
<p>It is also an error to call this function for a thread which is not running or paused (in the latter case, the thread will be resumed first) &ndash; if you do it, a <b>wxTHREAD_NOT_RUNNING</b> error will be returned. </p>

</div>
</div>
<a class="anchor" id="a8c6d835578dde71dd2c241c38336a4ba"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="interface_2wx_2thread_8h.html#a9e4ba0577f752fee0ba2133035f75ac2">wxThreadError</a> wxThread::Pause </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Suspends the thread. </p>
<p>Under some implementations (Win32), the thread is suspended immediately, under others it will only be suspended when it calls <a class="el" href="classwx_thread.html#a9a3acec44b06b2a2430c5659991a3eac" title="This function should be called periodically by the thread to ensure that calls to Pause() and Delete(...">TestDestroy()</a> for the next time (hence, if the thread doesn't call it at all, it won't be suspended).</p>
<p>This function can only be called from another thread context. </p>

</div>
</div>
<a class="anchor" id="afe81d37cd6cb6d5eb142773fb2c94562"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="interface_2wx_2thread_8h.html#a9e4ba0577f752fee0ba2133035f75ac2">wxThreadError</a> wxThread::Resume </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resumes a thread suspended by the call to <a class="el" href="classwx_thread.html#a8c6d835578dde71dd2c241c38336a4ba" title="Suspends the thread.">Pause()</a>. </p>
<p>This function can only be called from another thread context. </p>

</div>
</div>
<a class="anchor" id="a5d894750ffaac8fc42ee85aeff8bb4c0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="interface_2wx_2thread_8h.html#a9e4ba0577f752fee0ba2133035f75ac2">wxThreadError</a> wxThread::Run </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Starts the thread execution. </p>
<p>Note that once you <a class="el" href="classwx_thread.html#a5d894750ffaac8fc42ee85aeff8bb4c0" title="Starts the thread execution.">Run()</a> a <b>detached</b> thread, <em>any</em> function call you do on the thread pointer (you must allocate it on the heap) is <em>"unsafe"</em>; i.e. the thread may have terminated at any moment after <a class="el" href="classwx_thread.html#a5d894750ffaac8fc42ee85aeff8bb4c0" title="Starts the thread execution.">Run()</a> and your pointer may be dangling. See <a class="el" href="classwx_thread.html#thread_types">Types of wxThreads</a> for an example of safe manipulation of detached threads.</p>
<p>This function can only be called from another thread context.</p>
<p>Finally, note that once a thread has completed and its <a class="el" href="classwx_thread.html#af50fa7d3ac55002e367e79989b9cbc5d" title="This is the entry point of the thread.">Entry()</a> function returns, you cannot call <a class="el" href="classwx_thread.html#a5d894750ffaac8fc42ee85aeff8bb4c0" title="Starts the thread execution.">Run()</a> on it again (an assert will fail in debug builds or <code>wxTHREAD_RUNNING</code> will be returned in release builds). </p>

</div>
</div>
<a class="anchor" id="a09dfe3800bbfad53be303a4608d52959"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool wxThread::SetConcurrency </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>level</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the thread concurrency level for this process. </p>
<p>This is, roughly, the number of threads that the system tries to schedule to run in parallel. The value of 0 for <em>level</em> may be used to set the default one.</p>
<dl class="section return"><dt>Returns</dt><dd><span class="literal">true</span> on success or <span class="literal">false</span> otherwise (for example, if this function is not implemented for this platform &ndash; currently everything except Solaris). </dd></dl>

</div>
</div>
<a class="anchor" id="a6236828fe98e81103219a519fbd7091d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void wxThread::SetPriority </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>priority</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the priority of the thread, between 0 (lowest) and 100 (highest). </p>
<p>The following symbolic constants can be used in addition to raw values in 0..100 range:</p>
<ul>
<li><code>wxPRIORITY_MIN:</code> 0</li>
<li><code>wxPRIORITY_DEFAULT:</code> 50</li>
<li><code>wxPRIORITY_MAX:</code> 100 </li>
</ul>

</div>
</div>
<a class="anchor" id="a9ae47b39270c54dba5534af31f885ec6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void wxThread::Sleep </td>
          <td>(</td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>milliseconds</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pauses the thread execution for the given amount of time. </p>
<p>This is the same as <a class="el" href="group__group__funcmacro__time.html#ga66778879349f76fd833902d3767006fa" title="Sleeps for the specified number of milliseconds.">wxMilliSleep()</a>. </p>

</div>
</div>
<a class="anchor" id="a9a3acec44b06b2a2430c5659991a3eac"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool wxThread::TestDestroy </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This function should be called periodically by the thread to ensure that calls to <a class="el" href="classwx_thread.html#a8c6d835578dde71dd2c241c38336a4ba" title="Suspends the thread.">Pause()</a> and <a class="el" href="classwx_thread.html#a66796042bf5f3eb33a0ad3db85f686d4" title="Calling Delete() gracefully terminates a detached thread, either when the thread calls TestDestroy() ...">Delete()</a> will work. </p>
<p>If it returns <span class="literal">true</span>, the thread should exit as soon as possible. Notice that under some platforms (POSIX), implementation of <a class="el" href="classwx_thread.html#a8c6d835578dde71dd2c241c38336a4ba" title="Suspends the thread.">Pause()</a> also relies on this function being called, so not calling it would prevent both stopping and suspending thread from working. </p>

</div>
</div>
<a class="anchor" id="a7077fa46ffef0fd1d023628776598335"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classwx_thread.html">wxThread</a>* wxThread::This </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the thread object for the calling thread. </p>
<p><span class="literal">NULL</span> is returned if the calling thread is the main (GUI) thread, but <a class="el" href="classwx_thread.html#a1ee917ef87f986ba3b2ee26e620378e4" title="Returns true if the calling thread is the main application thread.">IsMain()</a> should be used to test whether the thread is really the main one because <span class="literal">NULL</span> may also be returned for the thread not created with <a class="el" href="classwx_thread.html" title="A thread is basically a path of execution through a program.">wxThread</a> class. Generally speaking, the return value for such a thread is undefined. </p>

</div>
</div>
<a class="anchor" id="a62ee778033013d3a4754b71b8cf2902e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classwx_thread.html#ade9497fa072fe19481086e6486dcc028">ExitCode</a> wxThread::Wait </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="interface_2wx_2thread_8h.html#a180bd0d42ba227657c3ad00194371a87">wxThreadWait</a>&#160;</td>
          <td class="paramname"><em>flags</em> = <code><a class="el" href="interface_2wx_2thread_8h.html#a180bd0d42ba227657c3ad00194371a87a47788167d370686ccade7904df7296f0">wxTHREAD_WAIT_BLOCK</a></code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Waits for a <b>joinable</b> thread to terminate and returns the value the thread returned from <a class="el" href="classwx_thread.html#af50fa7d3ac55002e367e79989b9cbc5d" title="This is the entry point of the thread.">Entry()</a> or <code>"(ExitCode)-1"</code> on error. </p>
<p>Notice that, unlike <a class="el" href="classwx_thread.html#a66796042bf5f3eb33a0ad3db85f686d4" title="Calling Delete() gracefully terminates a detached thread, either when the thread calls TestDestroy() ...">Delete()</a>, this function doesn't cancel the thread in any way so the caller waits for as long as it takes to the thread to exit.</p>
<p>You can only <a class="el" href="classwx_thread.html#a62ee778033013d3a4754b71b8cf2902e" title="Waits for a joinable thread to terminate and returns the value the thread returned from Entry() or &quot;(...">Wait()</a> for <b>joinable</b> (not detached) threads.</p>
<p>This function can only be called from another thread context.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">flags</td><td>As described in wxThreadWait documentation, wxTHREAD_WAIT_BLOCK should be used as the wait mode even although currently wxTHREAD_WAIT_YIELD is for compatibility reasons. This parameter is new in wxWidgets 2.9.2.</td></tr>
  </table>
  </dd>
</dl>
<p>See <a class="el" href="classwx_thread.html#thread_deletion">wxThread Deletion</a> for a broader explanation of this routine. </p>

</div>
</div>
<a class="anchor" id="a7a36099bab2d4be9d72cfd4cf76e8aa6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void wxThread::Yield </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Give the rest of the thread's time-slice to the system allowing the other threads to run. </p>
<p>Note that using this function is <b>strongly</b> discouraged, since in many cases it indicates a design weakness of your threading model (as does using <a class="el" href="classwx_thread.html#a9ae47b39270c54dba5534af31f885ec6" title="Pauses the thread execution for the given amount of time.">Sleep()</a> functions).</p>
<p>Threads should use the CPU in an efficient manner, i.e. they should do their current work efficiently, then as soon as the work is done block on a wakeup event (<a class="el" href="classwx_condition.html" title="wxCondition variables correspond to pthread conditions or to Win32 event objects.">wxCondition</a>, <a class="el" href="classwx_mutex.html" title="A mutex object is a synchronization object whose state is set to signaled when it is not owned by any...">wxMutex</a>, select(), poll(), ...) which will get signalled e.g. by other threads or a user device once further thread work is available. Using <a class="el" href="classwx_thread.html#a7a36099bab2d4be9d72cfd4cf76e8aa6" title="Give the rest of the thread&#39;s time-slice to the system allowing the other threads to run...">Yield()</a> or <a class="el" href="classwx_thread.html#a9ae47b39270c54dba5534af31f885ec6" title="Pauses the thread execution for the given amount of time.">Sleep()</a> indicates polling-type behaviour, since we're fuzzily giving up our timeslice and wait until sometime later we'll get reactivated, at which time we realize that there isn't really much to do and <a class="el" href="classwx_thread.html#a7a36099bab2d4be9d72cfd4cf76e8aa6" title="Give the rest of the thread&#39;s time-slice to the system allowing the other threads to run...">Yield()</a> again...</p>
<p>The most critical characteristic of <a class="el" href="classwx_thread.html#a7a36099bab2d4be9d72cfd4cf76e8aa6" title="Give the rest of the thread&#39;s time-slice to the system allowing the other threads to run...">Yield()</a> is that it's operating system specific: there may be scheduler changes which cause your thread to not wake up relatively soon again, but instead many seconds later, causing huge performance issues for your application.</p>
<p><b> With a well-behaving, CPU-efficient thread the operating system is likely to properly care for its reactivation the moment it needs it, whereas with non-deterministic, Yield-using threads all bets are off and the system scheduler is free to penalize them drastically</b>, and this effect gets worse with increasing system load due to less free CPU resources available. You may refer to various Linux kernel <code>sched_yield</code> discussions for more information.</p>
<p>See also <a class="el" href="classwx_thread.html#a9ae47b39270c54dba5534af31f885ec6" title="Pauses the thread execution for the given amount of time.">Sleep()</a>. </p>

</div>
</div>
</div><!-- contents -->

<address class="footer">
	<small>
		Generated on Thu Nov 27 2014 13:47:00 for wxWidgets by <a href="http://www.doxygen.org/index.html" target="_new">Doxygen</a> 1.8.2
	</small>
</address>
<script src="wxwidgets.js" type="text/javascript"></script>
</div><!-- #page_container -->
</body>
</html>
